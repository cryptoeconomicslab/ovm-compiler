    /**
     * Gets child of <%= property.definition.name %>(<%= property.definition.inputDefs %>).
     */
    function getChild<%= property.definition.name %>(bytes[] memory _inputs, bytes[] memory challengeInputs) private returns (types.Property memory) {
<%
        property.definition.propertyInputs.forEach((propertyInput, index) => {
-%>
        types.Property memory inputProperty<%=propertyInput.inputIndex%> = abi.decode(_inputs[<%=propertyInput.inputIndex%>], (types.Property));
<%
        if(propertyInput.children.length > 0) {
-%>
        types.Property memory inputProperty<%=propertyInput.inputIndex%>Child<%=propertyInput.children[0]%> = abi.decode(inputProperty<%=propertyInput.inputIndex%>.inputs[<%= propertyInput.children[0] %>], (types.Property));
<%
        }
-%>
<%
        })
-%>
<%  if(property.definition.predicate == 'And') { -%>
        uint256 challengeInput = abi.decode(challengeInputs[0], (uint256));
        bytes[] memory notInputs = new bytes[](1);
<%
      for(var j = 0;j < property.definition.inputs.length;j++) {
        var item = property.definition.inputs[j]
-%>
        if(challengeInput == <%= j %>) {
<%      if(item.isCompiled) { -%>
            bytes[] memory childInputs = new bytes[](<%= item.inputs.length %>);
<%- indent(include('constructInputs', {property: item, valName: 'childInputs', witnessName: 'challengeInputs'}), 4) -%>
            return getChild<%= item.predicate.source %>(childInputs, utils.subArray(challengeInputs, 1, challengeInputs.length));
<%      } else { -%>
<%-  indent(include('constructProperty', {property: item, valName: 'notInputs[0]', propIndex: j}), 4) -%>
<%      } -%>
        }
<%    } -%>
        return types.Property({
            predicateAddress: notAddress,
            inputs: notInputs
        });
<%  } else if(property.definition.predicate == 'ForAllSuchThat') {
      const quantifier = property.definition.inputs[0];
      const innerProperty = property.definition.inputs[2];
-%>
<%    if(innerProperty.isCompiled) { -%>
        bytes[] memory childInputs = new bytes[](<%= innerProperty.inputs.length %>);
<%- include('constructInputs', {property: innerProperty, valName: 'childInputs', witnessName: 'challengeInputs'}) -%>
        return getChild<%= innerProperty.predicate.source %>(childInputs, utils.subArray(challengeInputs, 1, challengeInputs.length));
<%    } else { -%>
        bytes[] memory notInputs = new bytes[](1);
<%-  include('constructProperty', {property: innerProperty, valName: 'notInputs[0]', propIndex: ''}) -%>
        return types.Property({
            predicateAddress: notAddress,
            inputs: notInputs
        });
<%    } -%>
<%  } else if(property.definition.predicate == 'Not') {
        const innerProperty = property.definition.inputs[0];
-%>
        bytes memory property;
<%-  include('constructProperty', {property: innerProperty, valName: 'property', propIndex: ''}) -%>
        return abi.decode(property, (types.Property));
<%  } else if(property.definition.predicate == 'ThereExistsSuchThat') {
        const quantifier = property.definition.inputs[0];
        const innerProperty = property.definition.inputs[2];
-%>
        bytes[] memory forAllSuchThatInputs = new bytes[](3);
        bytes[] memory notInputs = new bytes[](1);
<%-  include('constructProperty', {property: innerProperty, valName: 'notInputs[0]', propIndex: ''}) -%>
        forAllSuchThatInputs[0] = bytes("");
        forAllSuchThatInputs[1] = bytes("<%= property.definition.inputs[1] %>");
        forAllSuchThatInputs[2] = abi.encode(types.Property({
            predicateAddress: notAddress,
            inputs: notInputs
        }));
        return types.Property({
            predicateAddress: forAllSuchThatAddress,
            inputs: forAllSuchThatInputs
        });
<%  } else if(property.definition.predicate == 'Or') {  %>
        bytes[] memory andInputs = new bytes[](<%= property.definition.inputs.length %>);
<%
        property.definition.inputs.forEach((item, index) => {
-%>
        bytes[] memory notInputs<%= index %> = new bytes[](1);
<%-  include('constructProperty', {property: item, valName: 'notInputs' + index + '[0]', propIndex: index}) -%>
        andInputs[<%= index %>] = abi.encode(types.Property({
            predicateAddress: notAddress,
            inputs: notInputs<%= index %>
        }));
<%      }) -%>
        return types.Property({
            predicateAddress: andAddress,
            inputs: andInputs
        });
<%  } -%>
    }
