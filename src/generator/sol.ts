const text = "pragma solidity ^0.5.0;\npragma experimental ABIEncoderV2;\n\nimport {DataTypes as types} from \"../DataTypes.sol\";\nimport \"../UniversalAdjudicationContract.sol\";\nimport \"../Utils.sol\";\nimport \"./AtomicPredicate.sol\";\nimport \"./CompiledPredicate.sol\";\n\n<%\n  for(let c = 0;c < compiledPredicates.length;c++) {\n    const claimDef = compiledPredicates[c]\n%>\n/**\n * <%= claimDef.name %>(<%= claimDef.inputDefs %>)\n */\ncontract <%= claimDef.name %> {\n<%\n  for(var i = 0;i < claimDef.contracts.length;i++) {\n    let property = claimDef.contracts[i]\n-%>\n    bytes public <%= property.definition.name %> = bytes(\"<%= property.definition.name %>\");\n<%\n  }\n%>\n    UniversalAdjudicationContract adjudicationContract;\n    Utils utils;\n    address LessThan = address(<%= getAddress('LessThan') %>);\n    address Equal = address(<%= getAddress('Equal') %>);\n    address IsValidSignature = address(<%= getAddress('IsValidSignature') %>);\n    address Bytes = address(<%= getAddress('Bytes') %>);\n    address SU = address(<%= getAddress('SU') %>);\n    address IsContainedPredicate = address(<%= getAddress('IsContainedPredicate') %>);\n    address VerifyInclusionPredicate = address(<%= getAddress('VerifyInclusionPredicate') %>);\n    address IsValidStateTransitionPredicate = address(<%= getAddress('IsValidStateTransitionPredicate') %>);\n    address notAddress = address(<%= getAddress('Not') %>);\n    address andAddress = address(<%= getAddress('And') %>);\n    address forAllSuchThatAddress = address(<%= getAddress('ForAllSuchThat') %>);\n\n    constructor(address _adjudicationContractAddress, address _utilsAddress) {\n        adjudicationContract = UniversalAdjudicationContract(_adjudicationContractAddress);\n        utils = Utils(_utilsAddress);\n    }\n\n    /**\n     * @dev Validates a child node of the property in game tree.\n     */\n    function isValidChallenge(\n        bytes[] memory _inputs,\n        bytes[] memory _challengeInput,\n        types.Property memory _challenge\n    ) public returns (bool) {\n        require(\n            keccak256(abi.encode(getChild(_inputs, _challengeInput))) == keccak256(abi.encode(_challenge)),\n            \"_challenge must be valud child of game tree\"\n        );\n        return true;\n    }\n\n    function getChild(\n        bytes[] memory inputs,\n        bytes[] memory challengeInput\n    ) private returns (types.Property memory) {\n        bytes32 input0 = bytesToBytes32(inputs[0]);\n<%\n  claimDef.contracts.forEach((property) => {\n-%>\n        if(input0 == <%= property.definition.name %>) {\n            return getChild<%= property.definition.name %>(inputs, challengeInput);\n        }\n<%\n  })\n-%>\n    }\n\n    /**\n     * @dev check the property is true\n     */\n    function decide(bytes[] memory _inputs, bytes memory _witness) public view returns(bool) {\n        bytes32 input0 = bytesToBytes32(_inputs[0]);\n<%\n  claimDef.contracts.forEach((property) => {\n-%>\n        if(input0 == <%= property.definition.name %>) {\n            decide<%= property.definition.name %>(_inputs, _witness);\n        }\n<%\n  })\n-%>\n    }\n\n    function decideTrue(bytes[] memory _inputs, bytes[] memory _witness) public {\n        require(decide(_inputs, _witness), \"must be true\");\n        types.Property memory property = types.Property({\n            predicateAddress: address(this),\n            inputs: _inputs\n        });\n        adjudicationContract.setPredicateDecision(utils.getPropertyId(property), true);\n    }\n\n<%\n  claimDef.contracts.forEach((property) => {\n-%>\n<%- include('getChild', {property: property}); -%>\n<%\n  })\n-%>\n<%\n  claimDef.contracts.forEach((property) => {\n-%>\n<%- include('decide', {property: property}); -%>\n<%\n  })\n-%>\n\n}\n<% } %>\n"
export default text