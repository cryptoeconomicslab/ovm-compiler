const text = "pragma solidity ^0.5.0;\npragma experimental ABIEncoderV2;\n\nimport { DataTypes as types } from \"<%= getOVMPath() %>/DataTypes.sol\";\nimport \"<%= getOVMPath() %>/UniversalAdjudicationContract.sol\";\nimport \"<%= getOVMPath() %>/Utils.sol\";\nimport \"<%= getOVMPath() %>/Predicate/AtomicPredicate.sol\";\nimport \"<%= getOVMPath() %>/Predicate/CompiledPredicate.sol\";\n\n<%\n  for(let c = 0;c < compiledPredicates.length;c++) {\n    const claimDef = compiledPredicates[c]\n    const constants = claimDef.constants || []\n%>\n/**\n * <%= claimDef.name %>(<%= claimDef.inputDefs %>)\n */\ncontract <%= claimDef.name %> {\n<%\n  for(var i = 0;i < claimDef.contracts.length;i++) {\n    let property = claimDef.contracts[i]\n-%>\n    bytes public <%= property.definition.name %> = bytes(\"<%= property.definition.name %>\");\n<%\n  }\n%>\n    UniversalAdjudicationContract adjudicationContract;\n    Utils utils;\n    address IsLessThan = address(<%= getAddress('IsLessThan') %>);\n    address Equal = address(<%= getAddress('Equal') %>);\n    address IsValidSignature = address(<%= getAddress('IsValidSignature') %>);\n    address IsContained = address(<%= getAddress('IsContained') %>);\n    address VerifyInclusion = address(<%= getAddress('VerifyInclusion') %>);\n    address IsSameAmount = address(<%= getAddress('IsSameAmount') %>);\n    address notAddress = address(<%= getAddress('Not') %>);\n    address andAddress = address(<%= getAddress('And') %>);\n    address forAllSuchThatAddress = address(<%= getAddress('ForAllSuchThat') %>);\n<% constants.forEach(c => { -%>\n    <%= c.varType %> <%= c.name %>;\n<% }) -%>\n\n    constructor(\n        address _adjudicationContractAddress,\n        address _utilsAddress,\n        address _isLessThan,\n        address _equal,\n        address _isValidSignature,\n        address _isContained,\n        address _verifyInclusion,\n        address _isSameAmount,\n        address _notAddress,\n        address _andAddress,\n        address _forAllSuchThatAddress<% if(constants.length > 0){ %>,<% } %>\n<% constants.forEach((c, index) => { -%>\n        <%= c.varType %> <%= c.varType == 'bytes' ? 'memory' : '' %> _<%= c.name %><% if(index < constants.length - 1) { %>,<% } %>\n<% }) -%>\n    ) public {\n        adjudicationContract = UniversalAdjudicationContract(_adjudicationContractAddress);\n        utils = Utils(_utilsAddress);\n        IsLessThan = _isLessThan;\n        Equal = _equal;\n        IsValidSignature = _isValidSignature;\n        IsContained = _isContained;\n        VerifyInclusion = _verifyInclusion;\n        IsSameAmount = _isSameAmount;\n        notAddress = _notAddress;\n        forAllSuchThatAddress = _forAllSuchThatAddress;\n<% constants.forEach((c, index) => { -%>\n        <%= c.name %> = _<%= c.name %>;\n<% }) -%>\n    }\n\n    /**\n     * @dev Validates a child node of the property in game tree.\n     */\n    function isValidChallenge(\n        bytes[] memory _inputs,\n        bytes[] memory _challengeInput,\n        types.Property memory _challenge\n    ) public returns (bool) {\n        require(\n            keccak256(abi.encode(getChild(_inputs, _challengeInput))) == keccak256(abi.encode(_challenge)),\n            \"_challenge must be valud child of game tree\"\n        );\n        return true;\n    }\n\n    function getChild(\n        bytes[] memory inputs,\n        bytes[] memory challengeInput\n    ) private returns (types.Property memory) {\n        bytes32 input0 = keccak256(inputs[0]);\n<%\n  claimDef.contracts.forEach((property) => {\n-%>\n        if(input0 == keccak256(<%= property.definition.name %>)) {\n            return getChild<%= property.definition.name %>(inputs, challengeInput);\n        }\n<%\n  })\n-%>\n    }\n\n    /**\n     * @dev check the property is true\n     */\n    function decide(bytes[] memory _inputs, bytes[] memory _witness) public view returns(bool) {\n        bytes32 input0 = keccak256(_inputs[0]);\n<%\n  claimDef.contracts.forEach((property) => {\n-%>\n        if(input0 == keccak256(<%= property.definition.name %>)) {\n            decide<%= property.definition.name %>(_inputs, _witness);\n        }\n<%\n  })\n-%>\n    }\n\n    function decideTrue(bytes[] memory _inputs, bytes[] memory _witness) public {\n        require(decide(_inputs, _witness), \"must be true\");\n        types.Property memory property = types.Property({\n            predicateAddress: address(this),\n            inputs: _inputs\n        });\n        adjudicationContract.setPredicateDecision(utils.getPropertyId(property), true);\n    }\n\n<%\n  claimDef.contracts.forEach((property) => {\n-%>\n<%- include('getChild', {property: property}); -%>\n<%\n  })\n-%>\n<%\n  claimDef.contracts.forEach((property) => {\n-%>\n<%- include('decide', {property: property}); -%>\n<%\n  })\n-%>\n\n}\n<% } %>\n"
export default text